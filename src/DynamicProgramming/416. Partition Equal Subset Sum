// TABULATION APPROACH

class Solution {
    public boolean canPartition(int[] nums) {
        int total = 0;
        for (int i : nums) total += i;

        if (total % 2 != 0) return false;

        int target = total / 2;

        boolean[] dp = new boolean[target + 1];
        dp[0] = true;

        for (int i = 0; i < nums.length; i++) {
            int val = nums[i];

            for (int j = target; j >= val; j--) {
                boolean notTake = dp[j];
                boolean take = dp[j - val];
                dp[j] = take || notTake;
            }
        }
        return dp[target];
    }
}


// RECURSIVE APPROACH

Solution {
    public boolean canPartition(int[] nums) {
        int total = 0, n = nums.length;
        for (int i : nums) total += i;


        if (total % 2 != 0) return false;
        int target = total / 2;
        Boolean[][] dp = new Boolean[n][target + 1];

        return helper(nums, total, 0, 0, dp);
    }

    public boolean helper(int[] nums, int total, int sum, int idx, Boolean[][] dp) {
        // base case 1
        if (sum == total / 2) return true;
        // base case 2
        if (idx >= nums.length || sum > total / 2) return false;

        if (dp[idx][sum] != null) return dp[idx][sum];

        boolean include = helper(nums, total, sum + nums[idx], idx + 1, dp);
        boolean exclude = helper(nums, total, sum, idx + 1, dp);

        dp[idx][sum] = include || exclude;
        return dp[idx][sum];
    }
}
